package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/i-icc/xsd2proto/internal/model"
)

// Generator generates protobuf files from internal models
type Generator struct {
	indentLevel   int
	includeHeader bool
	version       string
}

// New creates a new protobuf generator
func New() *Generator {
	return &Generator{
		includeHeader: true,
	}
}

// SetHeaderOptions sets header generation options
func (g *Generator) SetHeaderOptions(includeHeader bool, version string) {
	g.includeHeader = includeHeader
	g.version = version
}

func (g *Generator) Generate(protoFile *model.ProtoFile) (string, error) {
	var content strings.Builder

	// Add header comment if enabled
	if g.includeHeader {
		content.WriteString("// This proto file was automatically generated from xsd by @https://github.com/i-icc/xsd2proto\n")
		if g.version != "" {
			content.WriteString(fmt.Sprintf("// Generated by xsd2proto version %s\n", g.version))
		}
		content.WriteString("\n")
	}

	content.WriteString(fmt.Sprintf("syntax = \"%s\";\n\n", protoFile.Syntax))

	if protoFile.Package != "" {
		content.WriteString(fmt.Sprintf("package %s;\n\n", protoFile.Package))
	}

	if len(protoFile.Imports) > 0 {
		for _, imp := range protoFile.Imports {
			content.WriteString(fmt.Sprintf("import \"%s\";\n", imp))
		}
		content.WriteString("\n")
	}

	if len(protoFile.Options) > 0 {
		var optionKeys []string
		for key := range protoFile.Options {
			optionKeys = append(optionKeys, key)
		}
		sort.Strings(optionKeys)

		for _, key := range optionKeys {
			content.WriteString(fmt.Sprintf("option %s = \"%s\";\n", key, protoFile.Options[key]))
		}
		content.WriteString("\n")
	}

	// Write enums
	for _, enum := range protoFile.Enums {
		enumContent, err := g.generateEnum(&enum)
		if err != nil {
			return "", fmt.Errorf("failed to generate enum %s: %w", enum.Name, err)
		}
		content.WriteString(enumContent)
		content.WriteString("\n")
	}

	for _, message := range protoFile.Messages {
		messageContent, err := g.generateMessage(&message, 0)
		if err != nil {
			return "", fmt.Errorf("failed to generate message %s: %w", message.Name, err)
		}
		content.WriteString(messageContent)
		content.WriteString("\n")
	}

	return content.String(), nil
}

func (g *Generator) generateMessage(message *model.ProtoMessage, indentLevel int) (string, error) {
	var content strings.Builder
	indent := strings.Repeat("  ", indentLevel)

	content.WriteString(fmt.Sprintf("%smessage %s {\n", indent, message.Name))

	for _, enum := range message.Enums {
		enumContent, err := g.generateEnum(&enum)
		if err != nil {
			return "", fmt.Errorf("failed to generate nested enum %s: %w", enum.Name, err)
		}
		lines := strings.Split(strings.TrimSpace(enumContent), "\n")
		for _, line := range lines {
			content.WriteString(fmt.Sprintf("%s  %s\n", indent, line))
		}
		content.WriteString("\n")
	}

	for _, nestedMessage := range message.Messages {
		nestedContent, err := g.generateMessage(&nestedMessage, indentLevel+1)
		if err != nil {
			return "", fmt.Errorf("failed to generate nested message %s: %w", nestedMessage.Name, err)
		}
		content.WriteString(nestedContent)
		content.WriteString("\n")
	}

	// Generate fields
	for _, field := range message.Fields {
		fieldContent := g.generateField(&field, indentLevel+1)
		content.WriteString(fieldContent)
	}

	content.WriteString(fmt.Sprintf("%s}\n", indent))
	return content.String(), nil
}

func (g *Generator) generateField(field *model.ProtoField, indentLevel int) string {
	indent := strings.Repeat("  ", indentLevel)

	var label string
	if field.Label == model.FieldLabelRepeated {
		label = "repeated "
	}

	fieldLine := fmt.Sprintf("%s%s%s %s = %d", indent, label, field.Type, field.Name, field.Number)

	if len(field.Options) > 0 {
		var options []string
		for key, value := range field.Options {
			options = append(options, fmt.Sprintf("%s = \"%s\"", key, value))
		}
		sort.Strings(options)
		fieldLine += fmt.Sprintf(" [%s]", strings.Join(options, ", "))
	}

	fieldLine += ";\n"
	return fieldLine
}

func (g *Generator) generateEnum(enum *model.ProtoEnum) (string, error) {
	var content strings.Builder

	content.WriteString(fmt.Sprintf("enum %s {\n", enum.Name))

	for _, value := range enum.Values {
		content.WriteString(fmt.Sprintf("  %s = %d;\n", value.Name, value.Number))
	}

	content.WriteString("}\n")
	return content.String(), nil
}

func (g *Generator) GenerateToFile(protoFile *model.ProtoFile, outputPath string) error {
	content, err := g.Generate(protoFile)
	if err != nil {
		return err
	}

	_ = content
	return fmt.Errorf("file writing not implemented yet")
}
